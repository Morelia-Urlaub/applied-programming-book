{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Numerische Datenanalyse\n",
    "\n",
    "Reines Python ist für numerische Datenanalyse aus technischen Gründen nicht performant genug. Um dieses Problem zu umgehen, wurden verschiede Pakete entwickelt. Die meisten Pakete orientieren sich dabei an der API, welche von [Numpy](https://www.numpy.org/) entwickelt und implementiert wurde. Deshalb legen wir hier einen besonderen Fokus auf Numpy.\n",
    "\n",
    "Numpy ist ein Paket um effizient array-basiert in Python zu rechnen. Es bietet unter Anderem:\n",
    "\n",
    "-  Datentypen:\n",
    "   -   ndarray: (mehrdimensionaler) Array eines wählbaren Datentyps\n",
    "   -   masked Arrays: maskierter Array, z.B. für Daten mit Landmaske\n",
    "-  Funktionen:\n",
    "   -   ufunc: operieren elementweise auf Arrays (+, -, sin, cos, ...)\n",
    "   -   ndarray methoden: z.B. mean, sum, max, transpose, dot ...\n",
    "   -   lineare Algebra\n",
    "   -   ...\n",
    "   \n",
    "Um Numpy zu verwenden, muss es erst importiert werden."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 1,
   "metadata": {},
   "outputs": [],
   "source": [
    "import numpy as np"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## ndarray\n",
    "\n",
    "Die Klasse [ndarray](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.html) bilded die Basis von Numpy. Ein ndarray Objekt repräsentiert einen multidimensionalen homogenen Array aus Elementen fixer Größe. Das heißt, dass alle Elemente vom gleichen Datentypen sind.\n",
    "\n",
    "Um ein ndarray Objekt zu erstellen, verwendet man eine der foldenden Funktionen:\n",
    "\n",
    "-   [numpy.array](https://docs.scipy.org/doc/numpy/reference/generated/numpy.array.html)\n",
    "-   [numpy.zeros](https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros.html)\n",
    "-   [numpy.empty](https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty.html)\n",
    "-   [numpy.ones](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones.html)\n",
    "-   [numpy.full](https://docs.scipy.org/doc/numpy/reference/generated/numpy.full.html)\n",
    "-   [numpy.zeros_like](https://docs.scipy.org/doc/numpy/reference/generated/numpy.zeros_like.html)\n",
    "-   [numpy.empty_like](https://docs.scipy.org/doc/numpy/reference/generated/numpy.empty_like.html)\n",
    "-   [numpy.ones_like](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ones_like.html)\n",
    "-   [numpy.full_like](https://docs.scipy.org/doc/numpy/reference/generated/numpy.full_like.html)\n",
    "\n",
    "Führe folgendes Beispiel aus:\n",
    "\n",
    "```python\n",
    "a = np.array(range(9), dtype=np.int)\n",
    "print(a, a[4], a[1:3])\n",
    "\n",
    "a[5] = 3.4\n",
    "print(a)\n",
    "\n",
    "b = a[1:2]\n",
    "b[0] = 20\n",
    "\n",
    "print(a)\n",
    "```\n",
    "\n",
    "**Beobachtung**:\n",
    "\n",
    "-   Arrays können über ein `iterable` initialisiert werden. Versuche andere `iterable`, wie Listen oder Tupel\n",
    "-   Indizierung und slicing funktioniert wie bei Listen\n",
    "-   Alle Elemente eines Arrays haben den selben Datentyp\n",
    "-   **Wichtig**: slicing erzeugt eine Referenz, keine Kopie!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Arrays haben Attribute, die seine Meta-Daten enthalten. Die Attribute sind:\n",
    "\n",
    "-   `ndim`: Anzahl der Dimensionen\n",
    "-   `shape`: Tupel der Längen der Dimensionen\n",
    "-   `size`: Anzahl aller Elemente\n",
    "-   `dtype`: Datentyp der Elemente\n",
    "-   `itemsize`: Elementgröße in Bytes\n",
    "\n",
    "```python\n",
    "a = np.array([[2, 3, 1], [5, 7, 3]])\n",
    "\n",
    "print(a)\n",
    "print(a.ndim)\n",
    "print(a.shape)\n",
    "print(a.size)\n",
    "print(a.dtype)\n",
    "print(a.itemsize)\n",
    "```\n",
    "\n",
    "**Aufgabe**:\n",
    "-   Was ändert sich, wenn man in der Initialisierung des Array eine Zahl zum float oder zu einer komplexen Zahl macht?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Wie anfangs erwähnt, gibt es viele Möglichkeiten, einen Array zu erzeugt. Probiere ein paar aus!\n",
    "\n",
    "```python\n",
    "# Array gefüllt mit Nullen\n",
    "z = np.zeros((3, 2))\n",
    "\n",
    "# Array gefüllt mit Einsen\n",
    "o = np.ones((5, 3))\n",
    "\n",
    "# Array mit Nullen mit den gleichen Meta-daten wie o\n",
    "zeros_from_ones = np.zeros_like(o)\n",
    "\n",
    "# Array ohne initialisierte Werte\n",
    "buffer = np.empty((3, 2))\n",
    "\n",
    "# 10x10 Identitätsmatrix\n",
    "a = np.eye(10)\n",
    "\n",
    "# Wie range aber auch für floats\n",
    "x1 = np.arange(1, 10, 0.1)\n",
    "\n",
    "x2 = np.linspace(0, 2 * np.pi, 100)\n",
    "\n",
    "y = np.sin(x)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Indizierung und Iteration\n",
    "\n",
    "Ein-dimensionale Arrays werden wie Listen indiziert und iteriert.\n",
    "\n",
    "```python\n",
    "a = np.arange(10) ** 3\n",
    "\n",
    "print(a[2])\n",
    "print(a[2:5])\n",
    "\n",
    "a[:6:2] = -1000\n",
    "print(a[::-1])\n",
    "\n",
    "for e in a:\n",
    "    print(i ** (1 / 3.))\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Multi-dimensionale Arrays können ein Index pro Achse haben. Dabei werden Indextupel automatisch mit `:` nach rechts aufgefüllt.\n",
    "\n",
    "```python\n",
    "a = np.random.random((5, 4, 2))\n",
    "\n",
    "print(a)\n",
    "print(a[2, 3, 1])\n",
    "print(a[:, 1, 1])\n",
    "print(a[1:3, :, :])\n",
    "\n",
    "print(a[-1])\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Man kann `...` als Platzhalter für soviele `:` verwenden, wie nötig sind.\n",
    "\n",
    "```python\n",
    "print(a[..., 0])\n",
    "print(a[2:4, ..., 1])\n",
    "\n",
    "# Beispiel für Ellipsis (...) Schreibweise:\n",
    "x = np.arange(2 * 3 * 2 * 5 * 4).reshape(2, 3, 2, 5, 4)\n",
    "\n",
    "print((x[1, 2, ...] == x[1, 2, :, :, :]).all())\n",
    "print((x[..., 3] == x[:, :, :, :, 3]).all())\n",
    "print((x[1, ..., 4, :] == x[1, :, :, 4, :]).all())\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Multi-dimensionale Arrays werden bezüglich der ersten Achse iteriert. Möchte man über alle Elemente iterieren, so kann man das `flat` Attribut verwenden.\n",
    "\n",
    "```python\n",
    "a = np.arange(5 * 3).reshape((3, 5))\n",
    "for row in a:\n",
    "    print(row)\n",
    "\n",
    "for element in a.flat:\n",
    "    print(element)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Reshape\n",
    "\n",
    "Manchmal möchte man die Form eines Arrays verändern. Dazu gibt es folgende Möglichkeiten:\n",
    "\n",
    "-   Das `shape` Attribut eines Arrays kann überschrieben werden.\n",
    "-   `transpose` gibt den transponierten Array zurück. Die Reihenfolge der Achsen ist umgedreht.\n",
    "-   [reshape](https://docs.scipy.org/doc/numpy/reference/generated/numpy.reshape.html) gibt eine Referenz zu den gleichen Daten mit gändertem shape zurück.\n",
    "-   [resize](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ndarray.resize.html) ändert den shape des Arrays selbt dun gibt `None` zurück.\n",
    "\n",
    "```python\n",
    "a = np.arange(3 * 4).reshape((3, 4))\n",
    "print(a)\n",
    "\n",
    "a.shape = (3, 2, 1, 2)\n",
    "print(a)\n",
    "\n",
    "print(a.transpose())\n",
    "a.resize((2, 6))\n",
    "\n",
    "print(a)\n",
    "b = a.reshape((3, -1))\n",
    "print(b.shape)\n",
    "\n",
    "# b referenziert die gleichen Daten wie a!\n",
    "b[2, 2] = 100\n",
    "print(a)\n",
    "```\n",
    "\n",
    "**Frage:**\n",
    "-   Was bedeute die `-1` in dem Aufruf der Methode `reshape`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Operationen\n",
    "\n",
    "Numpy bietet die gleichen arithmetischen und logischen Operationen an, die wir schon aus Python kennen. Diese Operationen arbeiten immer elementweise.\n",
    "\n",
    "```python\n",
    "a = np.arange(4)\n",
    "b = np.array([2, 7, 4.5, 1])\n",
    "\n",
    "print(a - b)\n",
    "print(a * b)\n",
    "print(b ** 2)\n",
    "print(b ** a)\n",
    "print(a % 3)\n",
    "print(10 * np.sin(a))\n",
    "print(b <= 4)\n",
    "\n",
    "# in-place addition\n",
    "a += b\n",
    "print(a)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "Die meisten unären Operatoren (Operatoren, welche nur ein  Argument haben) sind als Methode der ndarray Klasse implementiert. Häufig ist es möglich, die Operation auch nur entlang einer oder mehrere Dimensionen zu machen.\n",
    "\n",
    "```python\n",
    "a = np.array([[1, 2], [3, 4], [5, 6]])\n",
    "\n",
    "print(a)\n",
    "\n",
    "# Summe aller Elemente\n",
    "print(a.sum())\n",
    "\n",
    "# Summe entlang der ersten Dimension\n",
    "print(a.sum(axis=0))\n",
    "\n",
    "# Globales minimum\n",
    "print(a.min())\n",
    "\n",
    "# Globales maximum\n",
    "print(a.max())\n",
    "\n",
    "# Mittelwert\n",
    "print(a.mean())\n",
    "\n",
    "# Kummulative Summe enlang der zweiten Dimension\n",
    "print(a.cumsum(axis=1))\n",
    "\n",
    "# Skalarprodukt (eigentlich binärer Operator)\n",
    "print(a.dot(b), np.dot(a, b))\n",
    "\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "# Masked arrays\n",
    "\n",
    "[Masked arrays](https://docs.scipy.org/doc/numpy/reference/maskedarray.html) sind eine Subklasse von ndarray. Sie erweitern die ndarray Klasse um die Möglichkeit, Elemente zu maskieren, um sie bei Berechnungen außen vor zu lassen.\n",
    "\n",
    "Funktionen, welche masked arrays erzeugen oder mit ihnen umgehen, sind im Modul `numpy.ma` verfügbar.\n",
    "\n",
    "Elemente können maskiert werden, indem sie den Wert `numpy.ma.masked` zugewiesen bekommen. Dadurch wird das eigentliche Element nicht verändert, sondern nur als maskiert markiert.\n",
    "\n",
    "```python\n",
    "a = np.ma.ones((2, 2))\n",
    "\n",
    "# maskiere einen Wert\n",
    "a[0, 1] = np.ma.masked\n",
    "print(a)\n",
    "print(a.sum())\n",
    "```\n",
    "\n",
    "Die Maske ist als Attribut des masked array Objekts verfügbar. So kann man Elemente auch wieder demaskieren. Elementweise Operationen auf einem masked array werden nur auf die Elemente angewendet, die nicht maskiert sind.\n",
    "\n",
    "```python\n",
    "a *= 2\n",
    "print(a)\n",
    "a.mask[0, 1] = False\n",
    "print(a)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "## Universal functions\n",
    "\n",
    "Universal functions sind Funktionen, die Elementweise auf einem oder mehreren Arrays passender Größe arbeiten. Diese Funktionen sind der Grundstock der Numpy Funktionalität.\n",
    "\n",
    "Zu den Funktionen gehören:\n",
    "\n",
    "-   [all](https://docs.scipy.org/doc/numpy/reference/generated/numpy.all.html)\n",
    "-   [any](https://docs.scipy.org/doc/numpy/reference/generated/numpy.any.html)\n",
    "-   [apply_along_axis](https://docs.scipy.org/doc/numpy/reference/generated/numpy.apply_along_axis.html)\n",
    "-   [argmax](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmax.html)\n",
    "-   [argmin](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argmin.html)\n",
    "-   [argsort](https://docs.scipy.org/doc/numpy/reference/generated/numpy.argsort.html)\n",
    "-   [average](https://docs.scipy.org/doc/numpy/reference/generated/numpy.average.html)\n",
    "-   [bincount](https://docs.scipy.org/doc/numpy/reference/generated/numpy.bincount.html)\n",
    "-   [ceil](https://docs.scipy.org/doc/numpy/reference/generated/numpy.ceil.html)\n",
    "-   [clip](https://docs.scipy.org/doc/numpy/reference/generated/numpy.clip.html)\n",
    "-   [conj](https://docs.scipy.org/doc/numpy/reference/generated/numpy.conj.html)\n",
    "-   [corrcoef](https://docs.scipy.org/doc/numpy/reference/generated/numpy.corrcoef.html)\n",
    "-   [cov](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cov.html)\n",
    "-   [cross](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cross.html)\n",
    "-   [cumprod](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumprod.html)\n",
    "-   [cumsum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.cumsum.html)\n",
    "-   [diff](https://docs.scipy.org/doc/numpy/reference/generated/numpy.diff.html)\n",
    "-   [dot](https://docs.scipy.org/doc/numpy/reference/generated/numpy.dot.html)\n",
    "-   [floor](https://docs.scipy.org/doc/numpy/reference/generated/numpy.floor.html)\n",
    "-   [inner](https://docs.scipy.org/doc/numpy/reference/generated/numpy.inner.html)\n",
    "-   [linalg.inv](https://docs.scipy.org/doc/numpy/reference/generated/numpy.linalg.inv.html)\n",
    "-   [lexsort](https://docs.scipy.org/doc/numpy/reference/generated/numpy.lexsort.html)\n",
    "-   [maximum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.maximum.html)\n",
    "-   [mean](https://docs.scipy.org/doc/numpy/reference/generated/numpy.mean.html)\n",
    "-   [median](https://docs.scipy.org/doc/numpy/reference/generated/numpy.median.html)\n",
    "-   [minimum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.minimum.html)\n",
    "-   [nonzero](https://docs.scipy.org/doc/numpy/reference/generated/numpy.nonzero.html)\n",
    "-   [outer](https://docs.scipy.org/doc/numpy/reference/generated/numpy.outer.html)\n",
    "-   [prod](https://docs.scipy.org/doc/numpy/reference/generated/numpy.prod.html)\n",
    "-   [sort](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sort.html)\n",
    "-   [std](https://docs.scipy.org/doc/numpy/reference/generated/numpy.std.html)\n",
    "-   [sum](https://docs.scipy.org/doc/numpy/reference/generated/numpy.sum.html)\n",
    "-   [trace](https://docs.scipy.org/doc/numpy/reference/generated/numpy.trace.html)\n",
    "-   [transpose](https://docs.scipy.org/doc/numpy/reference/generated/numpy.transpose.html)\n",
    "-   [var](https://docs.scipy.org/doc/numpy/reference/generated/numpy.var.html)\n",
    "-   [vdot](https://docs.scipy.org/doc/numpy/reference/generated/numpy.vdot.html)\n",
    "-   [vectorize](https://docs.scipy.org/doc/numpy/reference/generated/numpy.vectorize.html)\n",
    "-   [where](https://docs.scipy.org/doc/numpy/reference/generated/numpy.where.html)\n",
    "\n",
    "**Aufgabe:**\n",
    "\n",
    "-   Schreibe eine Funktion, die den Winkel zwischen zwei N-dimensionalen Vektoren (1-dimensionale Arrays der Länge N) im Bogenmaß zurückgibt. Verwende dabei so viele numpy Funktionen wie möglich!"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "---\n",
    "# Broadcasting\n",
    "\n",
    "`universal functions` oder elementweise Operationen erwarten Arrays passender Größer. Häufig haben wir aber Daten, die nicht den gleichen shape haben, z.B. Meeresoberflächentemperatur (nlat x nlon), Längengrad (nlon) und Breitengrad (nlat). Trotzdem wollen wir so etwas wie\n",
    "\n",
    "```python\n",
    "mean_sst = (sst * np.cos(lat)).mean()\n",
    "```\n",
    "\n",
    "machen können. `Numpy` mach dafür das sogenannte [Broadcasting](https://docs.scipy.org/doc/numpy/user/basics.broadcasting.html), welches nach folgenden Regeln funktioniert:\n",
    "\n",
    "-   Falls alle Input Arrays nicht die gleiche Anzahl an Dimensionen haben, wird eine \"1\" zum Shape aller Arrays mit weniger Dimensionen **vorne angefügt**, bis alle Arrays den gleiche Rang haben.\n",
    "-   Die Dimensionen eines Arrays, welche Länge \"1\" haben werden so behandelt, als wären sie so lange wie die ensprechende Dimension des größten Arrays\n",
    "\n",
    "Da neue Dimensionen immer vorne angefügt werden, kann es sein, dass man von Hand neue Dimensionen hinzufügen muss. Dies kann man durch indizierung mit der Konstanten `numpy.newaxis` erreichen.\n",
    "\n",
    "```python\n",
    "a = np.arange(3 * 4 * 7).reshape(3, 4, 7)\n",
    "b = np.arange(7)\n",
    "c = np.arange(4)\n",
    "d = np.arange(3 * 7).reshape((3, 7))\n",
    "\n",
    "print(a, b)\n",
    "print(a * b)\n",
    "\n",
    "# das hier Funktioniert nicht!\n",
    "print(a * c)\n",
    "\n",
    "# aber das hier\n",
    "print(a * c[:, np.newaxis])\n",
    "\n",
    "print(a * b  * c[:, np.newaxis])\n",
    "print(a * b  * c[:, np.newaxis] * d[:, np.newaxis, :])\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.6.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
