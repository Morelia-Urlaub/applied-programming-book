{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Object-oriented programming (OOP)\n",
    "Object-oriented programming (OOP)is a programming paradigm (see introduction lecture), which allows to structure programmes in a way, that data and behaviour can be summarized in objects.\n",
    "\n",
    "For example, an object could represent a person. This person has characteristics (data) like name, age or address. Possible behaviour could be running, speaking or walking.\n",
    "\n",
    "We already used the object `Turtle`. It has characteristics like position and angle and behaviour like turning to the left or right and move foreward. With `Turtle` we already saw, that behaviour of an object can change its state (data). Additionally objects can also interact.\n",
    "\n",
    "So far we focussed on procedural programming. There tasks are collected as procedures (functions) and data is organized as data structures (lists, tuple, etc.). For OOP the object is the main element of the programming structure and a reasonable transcription of tasks in objects and their interactions is the essential component of the programming performance.\n",
    "\n",
    "With python one can, depending on the task, use procedural, object-oriented programming or a mixture of both, because it is a multi-paradigm programming language."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Classes\n",
    "\n",
    "Lets concentrate on the data first. Every object is an *instance* of a *class*. Classes serve to define new data structures from already existing ones (e.g. primitive data types, containers, different classes). They define the structure of an object, so to say classes are the objects blueprint.\n",
    "\n",
    "The simplest class does not contain any structure. It is defined as follows:\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"A simple class.\"\"\"\n",
    "    pass\n",
    "```\n",
    "\n",
    "`pass` is a task, that does not do anything. However it is needed, since python requires a text inset after the *class signature*. Classes also have a `docstring`!\n",
    "\n",
    "As a convention, class names are the only names in python, which are written capitalized. For more complex names, the [CamelCase notation](https://en.wikipedia.org/wiki/Camel_case) is used."
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Instances (objects)\n",
    "\n",
    "If classes are blueprints, instances represent the products, which are build from them.\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"A simple dog class.\"\"\"\n",
    "    pass\n",
    "\n",
    "jim = Dog()\n",
    "george = Dog()\n",
    "\n",
    "print(jim == george)\n",
    "```\n",
    "\n",
    "Every instance of a class has the same structure, but the actual values of its properties can differ. With the instantiation (when an object is created), there is reserved enough memory to save all the data for every object. Objects are `mutable`, so a allocation creates a reference and not a copy.\n",
    "\n",
    "```python\n",
    "jim2 = jim\n",
    "print(jim2 is jim)\n",
    "```\n",
    "\n",
    "If one wants to check, if a an object is created from a certain class, the function `isinstance(obj, class)` can be used.\n",
    "\n",
    "```python\n",
    "print(isinstance(jim, Dog))\n",
    "print(isinstance(george, Dog))\n",
    "print(isinstance(jim, george))\n",
    "```"
   ]
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "**Questions:**\n",
    "-   Of what type is `Dog`?\n",
    "-   Of what type is `Dog()`?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Attributes of instances\n",
    "\n",
    "Every class creates objects and every object can obtain properties, which are called attributes. To initialize attributes (to define its value at the creation of the object) the `__init__` method is used. All methods have at least one argument in their signature: the object itself, usually called `self`. As a convention this is left out while calling the method and is replaced by a reference on the instance automatically.\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"Simple Dog with attributes.\"\"\"\n",
    "    \n",
    "    def __init__(self, name, age, address=''):\n",
    "        \"\"\"Set name, age and probably the address of the Dog.\"\"\"\n",
    "        print(\"Constructor called\")\n",
    "        self.name = name\n",
    "        self.age = age\n",
    "        self.address = address\n",
    "\n",
    "jim = Person('Jim', 25)\n",
    "print(\n",
    "    'This is {}, {} years old. He is living in {}'\n",
    "    .format(jim.name, jim.age, jim.address)\n",
    ")\n",
    "\n",
    "jim.address = 'DÃ¼sternbrooker Weg 20'\n",
    "print('This is {a.name}, {a.age} years old. He is living in {a.address}'.format(a=jim))\n",
    "```\n",
    "\n",
    "As one can see, while creating the object `jim`, the method `__init__` is called. The attributes of an object can be called by using the `.`-notation."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Class attributes\n",
    "\n",
    "Instance attributes are different for every object of the class. There is also the possibility to define attributes for a whole class, which is then the same for all instances.\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"Person with class attribute.\"\"\"\n",
    "    \n",
    "    # class attribute\n",
    "    species = \"Mammal\"\n",
    "    \n",
    "    def __init__(self, name, age, address=''):\n",
    "        self.name = name\n",
    "        self.age = age\n",
    "        self.address = address\n",
    "        \n",
    "jim = Person('Jim', 45)\n",
    "george = Person('George', 61)\n",
    "\n",
    "print(jim.species, george.species)\n",
    "```\n",
    "\n",
    "To change a class attribute, the new value can be allocated on class level. Is the value allocated on instance level, a new instance attribute with the same name is created, which is then used preferably.\n",
    "\n",
    "```python\n",
    "Dog.species = 'Fish'\n",
    "judy = Dog('Judy', 30)\n",
    "print(judy.species, jim.species, george.species)\n",
    "\n",
    "george.species = 'Amphibian'\n",
    "print(judy.species, jim.species, george.species, george.__class__.species)\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Instance methods\n",
    "\n",
    "Instance methods are defined inside the class and represent possible behaviour of an object. Method signatures always contain a reference to the instance as a first argument, usually called `self`. When calling the method, this argument is omitted and passed by python automatically. Besides, the same rules hold for method signatures as for function signatures.\n",
    "\n",
    "It is possible to access all instance attributes, class attributes or methods within the method body via the reference to the instance `self`.\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"Simple Dog class with Method.\"\"\"\n",
    "    \n",
    "    species = \"Mammal\"\n",
    "    \n",
    "    def __init__(self, name, age):\n",
    "        self.name = name\n",
    "        self.age = age\n",
    "    \n",
    "    # Instanzmethode\n",
    "    def bark(self):\n",
    "        print('{} is barking'.format(self.name))\n",
    "    \n",
    "    def get_older(self):\n",
    "        self.age += 1\n",
    "        \n",
    "jim = Person('Jim', 15)\n",
    "jim.bark()\n",
    "\n",
    "jim.species = 'mammal'\n",
    "jim.bark()\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Inheritance\n",
    "\n",
    "Inheritance is the process where a class takes attributes and behaviour from another class. The new class is called *subclass* and the original class is called *parent class*.\n",
    "\n",
    "The intention behind this is, that the subclass overwrites or extends parts of the parent class. That way, a new class can be created, which mostly keeps the functionality of the parent class, but differs in certain parts or offers new functionalities. E.g. we can differentiate dogs into races and introduce a new class attribute.\n",
    "\n",
    "```python\n",
    "class Dog():\n",
    "    \"\"\"Simple Dog class with Method.\"\"\"\n",
    "\n",
    "    species = \"Mammal\"\n",
    "    \n",
    "    def __init__(self, name, age):\n",
    "        self.name = name\n",
    "        self.age = age\n",
    "\n",
    "    # Instanzmethode\n",
    "    def bark(self):\n",
    "        print('{} is barking.'.format(self.name))\n",
    "\n",
    "        \n",
    "class Labrador(Dog):\n",
    "    \"\"\"Simple class for Labrador.\"\"\"\n",
    "    breed = \"Labrador\"\n",
    "    \n",
    "    def bark(self):\n",
    "        print('{} the {} is barking.'.format(self.name, self.breed))\n",
    "        \n",
    "class Dobermann(Dog):\n",
    "    \"\"\"Simple class for Dobermann.\"\"\"\n",
    "    breed = \"Dobermann\"\n",
    "    \n",
    "    def bark(self):\n",
    "        print('{} the {} is barking.'.format(self.name, self.breed))\n",
    "\n",
    "        \n",
    "judy = Labrador('Judy', 24)\n",
    "jim = Dobermann('Jim', 23)\n",
    "\n",
    "judy.bark()\n",
    "jim.bark()\n",
    "```\n",
    "\n",
    "Here the method `bark` is overwritten for both classes `Labrador` and `Dobermann` identically. This should be improved:\n",
    "\n",
    "```python\n",
    "class DogiWithBreed(Dog):\n",
    "    def bark(self):\n",
    "        print('{} the {} is barking.'.format(self.name, self.breed))\n",
    "\n",
    "class Labrador(Dog):\n",
    "    \"\"\"Simple class for Labrador.\"\"\"\n",
    "    breed = \"Labrador\"\n",
    "        \n",
    "class Dobermann(Dog):\n",
    "    \"\"\"Simple class for Dobermann.\"\"\"\n",
    "    breed = \"Dobermann\"\n",
    "\n",
    "judy = Labrador('Judy', 24)\n",
    "jim = Dobermann('Jim', 23)\n",
    "\n",
    "judy.bark()\n",
    "jim.bark()\n",
    "```\n",
    "\n",
    "Inharitance serves to specialize classes and to extend their behaviour. This prevents repetition of code and creates flexible programming structures. Sometimes one needs to rely on the parent class to extend the subclasses. In particular if the `__init__` method is wished to be overwritten. Then the function [`super`](https://docs.python.org/3/library/functions.html#super) is used.\n",
    "\n",
    "```python\n",
    "class DogWithBreed(Dog):\n",
    "    \n",
    "    def __init__(self, name, age, special_breed=''):\n",
    "        # call __init__ from parent class but bound to this instance\n",
    "        super().__init__(name, age)\n",
    "        if special_breed:\n",
    "            self.breed = special_breed\n",
    "        \n",
    "    def bark(self):\n",
    "        print('{} the {} is barking.'.format(self.name, self.breed))\n",
    "\n",
    "class Labrador(Dog):\n",
    "    \"\"\"Simple class for Labrador.\"\"\"\n",
    "    breed = \"Labrador\"\n",
    "        \n",
    "class Dobermann(Dog):\n",
    "    \"\"\"Simple class for Dobermann.\"\"\"\n",
    "    breed = \"Dobermann\"\n",
    "\n",
    "judy = Labrador('Judy', 24, special_breed='Labrador mix')\n",
    "jim = Dobermann('Jim', 23)\n",
    "\n",
    "judy.bark()\n",
    "jim.bark()\n",
    "```"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  },
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "## Test your knowledge\n",
    "\n",
    "-   What is a class?\n",
    "-   What is an instance (object)?\n",
    "-   What is the relationship between class and object?\n",
    "-   Which convention holds when naming classes?\n",
    "-   How is a class instanced?\n",
    "-   How do you access the attributes and methods of an object?\n",
    "-   What is a method?\n",
    "-   What purpose has `self`?\n",
    "-   What is the purpose of `__init__` and when is that method called?\n",
    "-   Describe how inheritance prevents repetitions in the code.\n",
    "-   Can a subclass overwrite properties or behaviour of the parent class?If yes, how?"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.7.3"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
